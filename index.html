<!DOCTYPE html><html lang=en><meta charset=utf-8><title>AsyncAF - Documentation</title><meta content="The asynciest of async libs there ever was or ever will be...AsyncAF!?" name=description><meta content="AsyncAF - Documentation" property=og:title><meta content=website property=og:type><meta content=https://cdn.rawgit.com/AsyncAF/AsyncAF/1ce388a7/docs/custom/assets/async-af-logo.png property=og:image><meta content=AsyncAF property=og:site_name><meta content=https://async-af.js.org property=og:url><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/site.webmanifest rel=manifest><meta content=#2d89ef name=msapplication-TileColor><meta content=#ffffff name=theme-color><script src=scripts/prettify/prettify.js></script><script src=scripts/prettify/lang-css.js></script><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link href=styles/prettify.css rel=stylesheet><link href=styles/jsdoc.css rel=stylesheet><meta content="width=device-width,initial-scale=1" name=viewport><input class=nav-trigger id=nav-trigger type=checkbox> <label class="navicon-button x" for=nav-trigger><div class=navicon></div></label> <label class=overlay for=nav-trigger></label><nav><h2><a href=/>Home</a></h2><h3>Classes</h3><ul><li><a href=/AsyncAF>AsyncAF</a><ul class=methods><li data-type=method><a href=/AsyncAF#concatAF>concatAF</a><li data-type=method><a href=/AsyncAF#everyAF>everyAF</a><li data-type=method><a href=/AsyncAF#filterAF>filterAF</a><li data-type=method><a href=/AsyncAF#findAF>findAF</a><li data-type=method><a href=/AsyncAF#findIndexAF>findIndexAF</a><li data-type=method><a href=/AsyncAF#forEachAF>forEachAF</a><li data-type=method><a href=/AsyncAF#includesAF>includesAF</a><li data-type=method><a href=/AsyncAF#indexOfAF>indexOfAF</a><li data-type=method><a href=/AsyncAF#joinAF>joinAF</a><li data-type=method><a href=/AsyncAF#lastIndexOfAF>lastIndexOfAF</a><li data-type=method><a href=/AsyncAF#mapAF>mapAF</a><li data-type=method><a href=/AsyncAF#reduceAF>reduceAF</a><li data-type=method><a href=/AsyncAF#someAF>someAF</a><li data-type=method><a href=/AsyncAF#logAF>logAF</a><li data-type=method><a href=/AsyncAF#logAF_options>logAF.options</a><li data-type=method><a href=/AsyncAF#series>series</a><li data-type=method><a href=/AsyncAF#io>io</a><li data-type=method><a href=/AsyncAF#splitAF>splitAF</a></ul><li><a href=/AsyncAfWrapper>AsyncAfWrapper</a><ul class=methods><li data-type=method><a href=/AsyncAfWrapper#use>use</a></ul></ul><h3>Tutorials</h3><ul><li><a href=/tutorial-TOO_MANY_IMPORTS>Wrapper/Use: Too Many 🤬 Imports!?</a></ul></nav><div id=main><section class=readme><article><p><a><img src="https://img.shields.io/bundlephobia/minzip/async-af.svg?style=for-the-badge&amp;label=size&amp;colorB=466EF1" alt="npm package size (min + gzip)"></a><a href=https://www.npmjs.com/package/async-af target=_blank><img src="https://img.shields.io/npm/v/async-af.svg?style=for-the-badge&colorB=cb3837" alt="npm version"></a><a href=https://yarnpkg.com/en/package/async-af target=_blank><img src="https://img.shields.io/npm/v/async-af.svg?label=yarn&style=for-the-badge&colorB=2c8ebb" alt="yarn version"></a><a href=https://unpkg.com/async-af/ target=_blank><img src="https://img.shields.io/npm/v/async-af.svg?style=for-the-badge&colorB=ffcc2f&label=unpkg" alt="unpkg version"></a><a href=https://codecov.io/gh/AsyncAF/AsyncAF target=_blank><img src="https://img.shields.io/codecov/c/github/AsyncAF/AsyncAF.svg?style=for-the-badge&label=codecov&colorB=brightgreen" alt=codecov></a><a href=https://github.com/AsyncAF/AsyncAF/blob/master/README.md#license><img src="https://img.shields.io/npm/l/async-af.svg?style=for-the-badge&colorB=aaaaaa" alt="MIT License"></a><p align=center><a href=https://async-af.js.org target=_blank><p style=position:relative;left:24.165%;><img src=https://cdn.rawgit.com/AsyncAF/AsyncAF/1ce388a7/docs/custom/assets/async-af-logo.png></p></a><p><br><p>Working with promises or async/await?<p>Use AsyncAF to transform your code into beautiful asynchronous JavaScript chains, with methods similar to the ones we all know (and love! 😍) such as <code>map</code>, <code>forEach</code>, <code>filter</code>, <code>reduce</code>, and more.<p><a href=https://async-af.js.org/AsyncAF target=_blank>Check out the docs </a>for all available methods. 💙<br><h2>Usage</h2><pre class="prettyprint lang-js source"><code>const AsyncAF = require('async-af');

function getActiveUsers(userIds) {
  return AsyncAF(userIds)
    // map user ids to user objects with an async function
    .mapAF(async userId => {
      const user = await fetch(`fake-game-api/users/${userId}`);
      return user.json();
    })
    // filter by active users
    .filterAF(user => user.isActive);
}</code></pre><p>AsyncAF methods are await-able and then-able.<pre class="prettyprint lang-js source"><code>async function sendMsgToActiveUsers(msg) {
  const activeUsers = await getActiveUsers([1, 2, 3]);
  // send each active user a msg in series
  await AsyncAF(activeUsers).series.forEachAF(async ({id}) => {
    await sendMsg(id, msg); // hypothetical msg service that's rate-limited
  });
  console.log('message sent!');
}

function doSomethingElseWithActiveUsers() {
  return getActiveUsers([1, 2, 3]).then(activeUsers => {
    // ... do something else
  });
}</code></pre><p>If a <code>Promise</code> is passed into <a href=https://async-af.js.org/AsyncAF target=_blank><code>AsyncAF</code></a>, it will be settled before a method processes it.<pre class="prettyprint lang-js source"><code>const userMsg = Promise.resolve('I\'m [restricted word] AF right now')

const msgContainsBadWord = (msg, word = '[restricted word]') => AsyncAF(msg).includesAF(word);

msgContainsBadWord(userMsg); // resolves to true</code></pre><p><code>Array</code> methods will settle any promises in an array before processing them.<pre class="prettyprint lang-js source"><code>const findHighScoringUser = () => AsyncAF([
  fetch('fake-game-api/users/1').then(user => user.json()), // {id: 1, name: Aiden, score: 9001, ...}
  {id: 2, name: 'Bill', score: 3600, /* ... */},
  {id: 3, name: 'Cari', score: 5800, /* ... */},
])
  .findAF(({score}) => score > 9000);

findHighScoringUser(); // resolves to {id: 1, name: Aiden, score: 9001, ...}</code></pre><p><strong>Note</strong>: All <code>'AF'</code> methods have an <code>'AF-less'</code> alias so you can choose whether or not to make it obvious that they're AsyncAF methods.<p>For example:<pre class="prettyprint lang-js source"><code>const promises = [1, 2, 3].map(n => Promise.resolve(n));

AsyncAF(promises).map(n => n * 2).filter(n => n !== 4).forEach(n => console.log(n));
// or
AsyncAF(promises).mapAF(n => n * 2).filterAF(n => n !== 4).forEachAF(n => console.log(n));
// both log 2 then 6</code></pre><h2>Installation 💾</h2><p>Easy peasy, just<p><code>$ npm install --save async-af</code>,<p>right?<p>⚠️ Not so fast; there's actually several ways to include AsyncAF in your project/production site from easy to more complex:<p><details><summary>Easy 👍</summary><br>🔹 <strong>npm:</strong> <code>$ npm install --save async-af</code><p><p>🔸 <strong>yarn:</strong> <code>$ yarn add async-af</code><p>🔹 <strong>bower:</strong> <code>async-af</code> is no longer published to bower. To continue using it with bower, look into <a href=https://github.com/mjeanroy/bower-npm-resolver target=_blank><code>bower-npm-resolver</code></a>.<p>🔸 <strong>cdn:</strong> See the table for which script tag to use:<p><table align=left><th>mode<th>browsers<th>script tag<tr><td>development<td>modern (ES6+)<td><code class=language-html>&lt;script src=&quot;https&#58;//unpkg.com/async-af/index.js&quot;&gt;&lt;/script&gt;</code></tr><tr><td>development<td>legacy (ES5+)<td><code class=language-html>&lt;script src=&quot;https&#58;//unpkg.com/async-af/legacy/index.js&quot;&gt;&lt;/script&gt;</code></tr><tr><td>production<td>modern (ES6+)<td><code class=language-html>&lt;script src=&quot;https&#58;//unpkg.com/async-af/min.js&quot;&gt;&lt;/script&gt;</code></tr><tr><td>production<td>legacy (ES5+)<td><code class=language-html>&lt;script src=&quot;https&#58;//unpkg.com/async-af/legacy/min.js&quot;&gt;&lt;/script&gt;</code></tr></table><br></details><br><p><p><details><summary>More Complex 🤔</summary><br><p><p>🔹 <strong>scoped packages:</strong><blockquote><p>Instead of pulling in the entire AsyncAF library, you can install smaller standalone packages for each of the AsyncAF methods you intend to use; for example, <code>@async-af/map</code> and/or <code>@async-af/filter</code>; see further instructions in the documentation for <a href=https://async-af.js.org/AsyncAfWrapper target=_blank>AsyncAfWrapper</a> and <a href=https://async-af.js.org/AsyncAfWrapper#use target=_blank>AsyncAfWrapper.use</a>.</blockquote><p>🔸 <strong>scoped packages + <code>babel-plugin-transform-imports</code>:</strong><blockquote><p>If you use more than a few AsyncAF scoped packages in a file, you might start to build a wall of <code>import</code> statements to pull them all in. If this is an eyesore for you, look into <a href=https://www.npmjs.com/package/babel-plugin-transform-imports target=_blank><code>babel-plugin-transform-imports</code></a> and condense that ugly wall down to a single <code>import</code> statement! See <a href=https://async-af.js.org/tutorial-TOO_MANY_IMPORTS target=_blank>Wrapper/Use: Too Many 🤬 Imports!?</a> for a tutorial.</blockquote><p>🔹 <strong>es modules:</strong><blockquote><p>AsyncAF as well as its scoped packages are also published as es modules. This gives an opportunity to conditionally load <code>async-af</code> with ES6+ features in modern browsers and <code>async-af</code> with ES5-compatible features in legacy browsers.<p>Using the cdn scripts as an example:<pre class=prettyprint>
<code><code class=language-html>&lt;script type="module" src="https&#58;//unpkg.com/async-af/esm/index.js">&lt;/script></code>
<code class=language-html>&lt;script nomodule src="https&#58;//unpkg.com/async-af/legacy/index.js">&lt;/script></code></code></pre><p>or minimized for production:<pre class=prettyprint>
<code><code class=language-html>&lt;script type="module" src="https&#58;//unpkg.com/async-af/esm/min.js">&lt;/script></code>
<code class=language-html>&lt;script nomodule src="https&#58;//unpkg.com/async-af/legacy/min.js">&lt;/script></code></code></pre></blockquote><blockquote><p>The script with <code class="prettyprint language-html">&lt;script type=&quot;module&quot;&gt;</code> will load in any browser capable of loading es modules, while the script with <code class="prettyprint language-html">&lt;script nomodule&gt;</code> will act as a fallback for legacy browsers.<p>See <a href=https://philipwalton.com/articles/deploying-es2015-code-in-production-today/ target=_blank>here</a> and <a href=https://jakearchibald.com/2017/es-modules-in-browsers/ target=_blank>here</a> for further reading on this strategy.</blockquote></details><br><p><h2>A couple notes on performance 🚀</h2><h4>Built on Promises</h4><p>Despite AsyncAF's name (Async/Await Fun), its source code is written entirely without the use of <code>async/await</code>. Its chainable asynchronous JavaScript methods <em>are</em>, however, highly useful when <em>your</em> code makes use of <code>async/await</code> or <code>Promises</code>. This is important for performance because transpiling an <code>async function</code> with babel currently <a href=https://medium.com/@bluepnume/even-with-async-await-you-probably-still-need-promises-9b259854c161 target=_blank>results in some loooong code</a> due to pulling in things like <a href=https://facebook.github.io/regenerator/ target=_blank>Facebook's regenerator</a> and others to make it work.<p>Because AsyncAF instead runs your code with Promises behind the scenes, there's no need to transpile <code>async/await</code> in its ES6 or ES5-compatible distributions. This boils down to much smaller bundles when compared to an equivalent async library written <em>with</em> <code>async/await</code>.<h4>Use <a href=https://async-af.js.org/AsyncAF#series target=_blank><code>series</code></a> wisely</h4><p>The majority of AsyncAF's <code>Array</code> methods process promises in parallel by default. However, many methods have an option to process promises in series as well. You can tell AsyncAF to process promises in series within the next method invocation by setting a flag with <code>series</code> or its alias <code>io</code> (in order). See the documentation for <a href=https://async-af.js.org/AsyncAF#series target=_blank><code>series</code></a> for a full list of methods this works on.<p>In some cases, the time it takes to resolve an AsyncAF expression won't differ; for example:<pre class="prettyprint lang-js source"><code>import AsyncAF, {logAF} from 'async-af';
import delay from 'delay';

logAF.options({label: false});

const bools = [
  () => delay(3000, {value: true}),
  () => delay(2000, {value: false}),
  () => delay(1000, {value: false}),
];

logAF('parallel', AsyncAF(bools).someAF(n => n()));
logAF('series', AsyncAF(bools).series.someAF(n => n()));

// series true
// in 3.000 secs
// parallel true
// in 3.000 secs</code></pre><p>Other times, processing promises in parallel will be faster:<pre class="prettyprint lang-js source"><code>const bools = [
  () => delay(3000, {value: false}),
  () => delay(2000, {value: true}),
  () => delay(1000, {value: false}),
];

logAF('parallel', AsyncAF(bools).someAF(n => n()));
logAF('series', AsyncAF(bools).series.someAF(n => n()));

// parallel true
// in 3.000 secs
// series true
// in 5.000 secs</code></pre><p>And yet other times, processing promises in series will be faster:<pre class="prettyprint lang-js source"><code>const bools = [
  () => delay(3000, {value: true}),
  () => delay(4000, {value: false}),
  () => delay(5000, {value: false}),
];

logAF('parallel', AsyncAF(bools).someAF(n => n()));
logAF('series', AsyncAF(bools).series.someAF(n => n()));

// series true
// in 3.000 secs
// parallel true
// in 5.000 secs</code></pre><p>Being cognizant of when to use <code>series</code> vs. when to rely on the default parallel behavior can help increase the performance of your asynchronous code.<p>Another use case for <code>series</code> might be if you're sending multiple requests to a rate-limited API. In that case you may not want to throw a ton of parallel requests at the API, but rather wait for each one in series.<div>Love AsyncAF?&nbsp;&nbsp;<iframe frameborder=0 height=30px scrolling=0 src="https://ghbtns.com/github-btn.html?user=AsyncAF&repo=AsyncAF&type=star&count=false" style=position:absolute width=160px></iframe></div><p>See something to improve? <a href=https://github.com/AsyncAF/AsyncAF/issues>File an issue</a> or <a href=https://github.com/AsyncAF/AsyncAF/blob/master/CONTRIBUTING.md>see how to contribute</a>.💙<h2>License</h2><p>AsyncAF is licensed under the <a href=https://choosealicense.com/licenses/mit/ target=_blank>MIT License</a>, so you can pretty much use it however you want<p>(but <a href=https://github.com/AsyncAF/AsyncAF/blob/master/LICENSE>click here</a> or <a href=https://app.fossa.io/projects/git%2Bgithub.com%2FAsyncAF%2FAsyncAF/refs/branch/master/ target=_blank>here</a> to get into specifics).<p><a href=https://app.fossa.io/projects/git%2Bgithub.com%2FAsyncAF%2FAsyncAF/refs/branch/master/ target=_blank><img src="https://app.fossa.io/api/projects/git%2Bgithub.com%2FAsyncAF%2FAsyncAF.svg?type=large" alt="FOSSA Status"></a></article></section></div><br class=clear><footer>Documentation generated by <a href=https://github.com/jsdoc3/jsdoc>JSDoc 3.5.5</a> on Thursday, November 15, 2018 using the <a href=https://github.com/AsyncAF/docdash>AsyncAF/docdash</a> theme.</footer><script>prettyPrint()</script><script src=scripts/linenumber.js></script>
