<!DOCTYPE html><html lang=en><meta charset=utf-8><title>AsyncAF - Documentation</title><meta content="Async/Await Fun" name=description><meta content="AsyncAF - Documentation" property=og:title><meta content=website property=og:type><meta content=https://cdn.rawgit.com/AsyncAF/AsyncAF/1ce388a7/docs/custom/assets/async-af-logo.png property=og:image><meta content=AsyncAF property=og:site_name><meta content=https://async-af.js.org property=og:url><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/site.webmanifest rel=manifest><meta content=#2d89ef name=msapplication-TileColor><meta content=#ffffff name=theme-color><script src=scripts/prettify/prettify.js></script><script src=scripts/prettify/lang-css.js></script><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link href=styles/prettify.css rel=stylesheet><link href=styles/jsdoc.css rel=stylesheet><meta content="width=device-width,initial-scale=1" name=viewport><input class=nav-trigger id=nav-trigger type=checkbox> <label class="navicon-button x" for=nav-trigger><div class=navicon></div></label> <label class=overlay for=nav-trigger></label><nav><h2><a href=index.html>Home</a></h2><h3>Classes</h3><ul><li><a href=AsyncAF.html>AsyncAF</a><ul class=methods><li data-type=method><a href=AsyncAF.html#everyAF>everyAF</a><li data-type=method><a href=AsyncAF.html#filterAF>filterAF</a><li data-type=method><a href=AsyncAF.html#findAF>findAF</a><li data-type=method><a href=AsyncAF.html#findIndexAF>findIndexAF</a><li data-type=method><a href=AsyncAF.html#forEachAF>forEachAF</a><li data-type=method><a href=AsyncAF.html#includesAF>includesAF</a><li data-type=method><a href=AsyncAF.html#indexOfAF>indexOfAF</a><li data-type=method><a href=AsyncAF.html#joinAF>joinAF</a><li data-type=method><a href=AsyncAF.html#lastIndexOfAF>lastIndexOfAF</a><li data-type=method><a href=AsyncAF.html#mapAF>mapAF</a><li data-type=method><a href=AsyncAF.html#reduceAF>reduceAF</a><li data-type=method><a href=AsyncAF.html#someAF>someAF</a><li data-type=method><a href=AsyncAF.html#logAF>logAF</a><li data-type=method><a href=AsyncAF.html#logAF_options>logAF.options</a><li data-type=method><a href=AsyncAF.html#splitAF>splitAF</a></ul><li><a href=AsyncAfWrapper.html>AsyncAfWrapper</a><ul class=methods><li data-type=method><a href=AsyncAfWrapper.html#use>use</a></ul></ul><h3>Tutorials</h3><ul><li><a href=tutorial-TOO_MANY_IMPORTS.html>Wrapper/Use: Too Many ðŸ¤¬ Imports!?</a></ul></nav><div id=main><h1 class=page-title>AsyncAF</h1><section><header><h2>AsyncAF</h2></header><article><div class=container-overview><h4 class=name id=AsyncAF><span class=type-signature></span>new AsyncAF<span class=signature>(data)</span><span class=type-signature> &rarr; {Object}</span></h4><div class=description><p>class that holds all the AsyncAF methods<p>while AsyncAF is a class, it can create instances with or without the <code>new</code> keyword</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.0.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li><a href=AsyncAfWrapper.html>AsyncAfWrapper</a></ul></dl><h5>Example</h5><pre class=prettyprint><code>const promises = [1, 2, 3].map(n => Promise.resolve(n));


AsyncAF(promises).mapAF(n => n * 2).filterAF(n => n !== 4).forEachAF(n => console.log(n));
// logs 2 then 6</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th class=last>Description<tbody><tr><td class=name><code>data</code><td class=type><span class=param-type>any</span><td class="last description"><p>the data to be wrapped by the AsyncAF class; can be promises or non-promises</table><h5>Returns:</h5><div class=param-desc><p>returns an instance of AsyncAF wrapping the passed in data</div><dl class=param-type><dt>Type<dd><span class=param-type>Object</span></dl></div><h3 class=subsection-title>Methods</h3><h4 class=name id=everyAF><span class=type-signature></span>everyAF<span class=signature>(callback, thisArg<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Boolean>}</span></h4><div class=description><p>tests whether all elements in the array pass the test implemented by the provided callback function<p>if any elements are a <code>Promise</code>, they will first be resolved in parallel and then tested</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.2.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>every</ul></dl><h5>Example</h5><pre class=prettyprint><code>const promises = [1, 2, 3].map(n => Promise.resolve(n));


// basic usage
const allAreOdd = AsyncAF(promises).everyAF(n => n % 2);

console.log(allAreOdd); // Promise that resolves to false

AsyncAF.logAF(allAreOdd); // logs false


// using .then
AsyncAF(promises).everyAF(n => n % 2).then(allAreOdd => {
  console.log(allAreOdd); // logs false
});


// inside an async function
(async () => {
  const allAreNums = await AsyncAF(promises).everyAF(
    n => typeof n === 'number'
  );
  console.log(allAreNums); // logs true
})();</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>callback</code><td class=type><span class=param-type>Function</span><td class=attributes><td class="last description"><p>function that tests each element of the array<p><code>callback</code> accepts three arguments:<ul><li><code>currentValue</code> value of the current element being processed in the array<li><code>index</code><em><code>(optional)</code></em> index of <code>currentValue</code> in the array<li><code>array</code><em><code>(optional)</code></em> the array that <code>everyAF</code> is being applied to</ul><tr><td class=name><code>thisArg</code><td class=type><span class=param-type>Object</span><td class=attributes>&lt;optional><br><td class="last description"><p>value to use as <code>this</code> when executing <code>callback</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to <code>true</code> if the callback function returns a truthy value for every array element; otherwise, <code>false</code></div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Boolean></span></dl><h4 class=name id=filterAF><span class=type-signature></span>filterAF<span class=signature>(callback, thisArg<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Array>}</span></h4><div class=description><p>creates a new <code>Array</code> with all elements that pass the test implemented by the provided callback function<p>if any elements are a <code>Promise</code>, they will first be resolved in parallel and then tested</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.0.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>filter</ul></dl><h5>Example</h5><pre class=prettyprint><code>const promises = [1, 2, 3].map(n => Promise.resolve(n));


// basic usage
const odds = AsyncAF(promises).filterAF(n => n % 2);

console.log(odds); // Promise that resolves to [1, 3]

AsyncAF.logAF(odds); // logs [1, 3]


// using .then
AsyncAF(promises).filterAF(n => n % 2).then(odds => {
  console.log(odds); // logs [1, 3]
});


// inside an async function
(async () => {
  const odds = await AsyncAF(promises).filterAF(
    n => n % 2
  );
  console.log(odds); // logs [1, 3]
})();</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>callback</code><td class=type><span class=param-type>Function</span><td class=attributes><td class="last description"><p>function that tests each element of the array; return <code>true</code> to keep the element, <code>false</code> to filter it out<p><code>callback</code> accepts three arguments:<ul><li><code>currentValue</code> value of the current element being processed in the array<li><code>index</code><em><code>(optional)</code></em> index of <code>currentValue</code> in the array<li><code>array</code><em><code>(optional)</code></em> the array that <code>filterAF</code> is being applied to</ul><tr><td class=name><code>thisArg</code><td class=type><span class=param-type>Object</span><td class=attributes>&lt;optional><br><td class="last description"><p>value to use as <code>this</code> when executing <code>callback</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to a new <code>Array</code> with the elements that pass the test; if no elements pass the test, the promise will resolve to an empty array</div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Array></span></dl><h4 class=name id=findAF><span class=type-signature></span>findAF<span class=signature>(callback, thisArg<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;any>}</span></h4><div class=description><p>returns the value of the first element in the array that satisfies the provided callback function; otherwise, <code>undefined</code></div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.5.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>find</ul></dl><h5>Example</h5><pre class=prettyprint><code>const inventory = [
 {name: 'nuts', quantity: 2000},
 {name: 'bolts', quantity: 5000},
 {name: 'screws', quantity: 9001}
].map(part => Promise.resolve(part));

AsyncAF(inventory).findAF(part => part.name === 'screws');
// Promise that resolves to {name: 'screws', quantity: 9001}</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>callback</code><td class=type><span class=param-type>Function</span><td class=attributes><td class="last description"><p>function to test each element in the array<p><code>callback</code> accepts three arguments:<ul><li><code>currentValue</code> value of the current element being processed in the array<li><code>index</code><em><code>(optional)</code></em> index of <code>currentValue</code> in the array<li><code>array</code><em><code>(optional)</code></em> the array that findAF is being applied to</ul><tr><td class=name><code>thisArg</code><td class=type><span class=param-type>Object</span><td class=attributes>&lt;optional><br><td class="last description"><p>value to use as <code>this</code> when executing <code>callback</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to the first element in the array that passes the test; otherwise, undefined</div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;any></span></dl><h4 class=name id=findIndexAF><span class=type-signature></span>findIndexAF<span class=signature>(callback, thisArg<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Number>}</span></h4><div class=description><p>returns the index of the first element in the array that satisfies the provided callback function; otherwise, <code>-1</code></div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.5.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>findIndex</ul></dl><h5>Example</h5><pre class=prettyprint><code>const inventory = [
 {name: 'nuts', quantity: 2000},
 {name: 'bolts', quantity: 5000},
 {name: 'screws', quantity: 9001}
].map(part => Promise.resolve(part));

AsyncAF(inventory).findAF(part => part.name === 'screws');
// Promise that resolves to 2</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>callback</code><td class=type><span class=param-type>Function</span><td class=attributes><td class="last description"><p>function to test each element in the array<p><code>callback</code> accepts three arguments:<ul><li><code>currentValue</code> value of the current element being processed in the array<li><code>index</code><em><code>(optional)</code></em> index of <code>currentValue</code> in the array<li><code>array</code><em><code>(optional)</code></em> the array that findIndexAF is being applied to</ul><tr><td class=name><code>thisArg</code><td class=type><span class=param-type>Object</span><td class=attributes>&lt;optional><br><td class="last description"><p>value to use as <code>this</code> when executing <code>callback</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to the index of the first element in the array that passes the test; otherwise, <code>-1</code></div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Number></span></dl><h4 class=name id=forEachAF><span class=type-signature></span>forEachAF<span class=signature>(callback, thisArg<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;undefined>}</span></h4><div class=description><p>executes a callback function on each element in an array<p>if any elements are a <code>Promise</code>, they will first be resolved in parallel and then processed</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.0.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>forEach</ul></dl><h5>Example</h5><pre class=prettyprint><code>const promises = [1, 2].map(n => Promise.resolve(n));


AsyncAF(promises).forEachAF(el => {
  console.log(el); // logs 1 then 2
});</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>callback</code><td class=type><span class=param-type>Function</span><td class=attributes><td class="last description"><p>function to execute for each element<p><code>callback</code> accepts three arguments:<ul><li><code>currentValue</code> value of the current element being processed in the array<li><code>index</code><em><code>(optional)</code></em> index of <code>currentValue</code> in the array<li><code>array</code><em><code>(optional)</code></em> the array that forEachAF is being applied to</ul><tr><td class=name><code>thisArg</code><td class=type><span class=param-type>Object</span><td class=attributes>&lt;optional><br><td class="last description"><p>value to use as <code>this</code> when executing <code>callback</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to <code>undefined</code></div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;undefined></span></dl><h4 class=name id=includesAF><span class=type-signature></span>includesAF<span class=signature>(searchItem, fromIndex<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Boolean>}</span></h4><div class=description><p>determines whether an array, string, or array-like object includes a certain element or string, returning true or false as appropriate</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.4.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>includes</ul></dl><h5>Example</h5><pre class=prettyprint><code>// includesAF on an array of promises
const nums = [1, 2, 3].map(n => Promise.resolve(n));

AsyncAF(nums).includesAF(2); // Promise that resolves to true

AsyncAF(nums).includesAF(5); // Promise that resolves to false

AsyncAF(nums).includesAF(1, 1); // Promise that resolves to false

AsyncAF(nums).includesAF(3, -1); // Promise that resolves to true

// includesAF on a promise-wrapped string
const string = Promise.resolve('test string');

AsyncAF(string).includesAF('test'); // Promise that resolves to true

AsyncAF(string).includesAF('nope'); // Promise that resolves to false

AsyncAF(string).includesAF('test', 5); // Promise that resolves to false

AsyncAF(string).includesAF('string', -6); // Promise that resolves to true

// includesAF on an array-like object
(async function () {
  if (await AsyncAF(arguments).includesAF(2)) {
    console.log('2 is included');
  }
})(1, 2, 3); // logs '2 is included'</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th>Default<th class=last>Description<tbody><tr><td class=name><code>searchItem</code><td class=type><span class=param-type>any</span><td class=attributes><td class=default><td class="last description"><p>the element or string to search for<tr><td class=name><code>fromIndex</code><td class=type><span class=param-type>Number</span><td class=attributes>&lt;optional><br><td class=default><code>0</code><td class="last description"><p>the index at which to begin searching for <code>searchItem</code>; a negative value searches from the index of <code>array/string.length - fromIndex</code>; defaults to <code>0</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to <code>true</code> if <code>searchItem</code> is found; otherwise, <code>false</code></div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Boolean></span></dl><h4 class=name id=indexOfAF><span class=type-signature></span>indexOfAF<span class=signature>(searchItem, fromIndex<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Number>}</span></h4><div class=description><p>returns the first index of the specified element or string in an array, string, or array-like object, starting the search at <code>fromIndex</code>; if the value is not found, returns <code>-1</code></div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.5.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>indexOf</ul></dl><h5>Example</h5><pre class=prettyprint><code>// indexOfAF on an array of promises
const nums = [1, 2, 3].map(n => Promise.resolve(n));

AsyncAF(nums).indexOfAF(2); // Promise that resolves to 1

AsyncAF(nums).indexOfAF(5); // Promise that resolves to -1

AsyncAF(nums).indexOfAF(1, 1); // Promise that resolves to -1

AsyncAF(nums).indexOfAF(3, -1); // Promise that resolves to 2

// indexOfAF on a promise-wrapped string
const string = Promise.resolve('test string');

AsyncAF(string).indexOfAF('test'); // Promise that resolves to 0

AsyncAF(string).indexOfAF('nope'); // Promise that resolves to -1

AsyncAF(string).indexOfAF('test', 5); // Promise that resolves to -1

AsyncAF(string).indexOfAF('string', -6); // Promise that resolves to 5

// indexOfAF on an array-like object
(async function () {
  if (await AsyncAF(arguments).indexOfAF(2) > -1) {
    console.log('2 is included');
  }
})(1, 2, 3); // logs '2 is included'</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th>Default<th class=last>Description<tbody><tr><td class=name><code>searchItem</code><td class=type><span class=param-type>any</span><td class=attributes><td class=default><td class="last description"><p>the element or string to search for<tr><td class=name><code>fromIndex</code><td class=type><span class=param-type>Number</span><td class=attributes>&lt;optional><br><td class=default><code>0</code><td class="last description"><p>the index at which to begin searching for <code>searchItem</code>; a negative value searches from the index of <code>array/string.length - fromIndex</code>; defaults to <code>0</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to the index of <code>searchItem</code> if found; otherwise, <code>-1</code></div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Number></span></dl><h4 class=name id=joinAF><span class=type-signature></span>joinAF<span class=signature>(separator<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;String>}</span></h4><div class=description><p>joins all elements of an array or array-like object into a string and returns that string</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.6.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>join</ul></dl><h5>Example</h5><pre class=prettyprint><code>const animals = ['cow', 'chicken', 'cat', 'dog'].map(a => Promise.resolve(a));

// joinAF separator defaults to ','
AsyncAF(animals).joinAF(); // Promise that resolves to 'cow,chicken,cat,dog'

// specifying separator
AsyncAF(animals).joinAF(' &amp; '); // Promise that resolves to 'cow &amp; chicken &amp; cat &amp; dog'

// a non-string separator will be converted to a string
AsyncAF(animals).joinAF(2); // Promise that resolves to 'cow2chicken2cat2dog'

// empty string separator
AsyncAF(animals).joinAF(''); // Promise that resolves to 'cowchickencatdog'

// joining an empty array returns an empty string
AsyncAF([]).joinAF('+'); // Promise that resolves to ''

// joinAF on an array-like object
(async function () {
 const list = await AsyncAF(arguments).joinAF(' - ');
 console.log(`Shopping List: ${list}`);
})('eggs', 'milk', 'butter', 'pancake mix');
// Shopping List: eggs - milk - butter - pancake mix</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th>Default<th class=last>Description<tbody><tr><td class=name><code>separator</code><td class=type><span class=param-type>any</span><td class=attributes>&lt;optional><br><td class=default><code>','</code><td class="last description"><p>the string that separates each element in the resulting string; defaults to <code>','</code>; non-string separators will be converted to strings if necessary; if <code>separator</code> is an empty string <code>''</code>, the array elements are joined without any characters between them</table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to a string with all array elements joined; if array.length is <code>0</code>, an empty string <code>''</code> is returned</div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;String></span></dl><h4 class=name id=lastIndexOfAF><span class=type-signature></span>lastIndexOfAF<span class=signature>(searchItem, fromIndex<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Number>}</span></h4><div class=description><p>returns the last index of the specified element or string, searching backwards in an array, string, or array-like object; <code>fromIndex</code> offsets the start of the search; if the value is not found, returns <code>-1</code></div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.6.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>lastIndexOf</ul></dl><h5>Example</h5><pre class=prettyprint><code>// lastIndexOfAF on an array of promises
const nums = [1, 1, 2, 2, 3, 3].map(n => Promise.resolve(n));

AsyncAF(nums).lastIndexOfAF(2); // Promise that resolves to 3

AsyncAF(nums).lastIndexOfAF(5); // Promise that resolves to -1

AsyncAF(nums).lastIndexOfAF(2, -4); // Promise that resolves to 2

AsyncAF(nums).lastIndexOfAF(3, -3); // Promise that resolves to -1

// lastIndexOfAF on a promise-wrapped string
const string = Promise.resolve('test string to test');

AsyncAF(string).lastIndexOfAF('test'); // Promise that resolves to 15

AsyncAF(string).lastIndexOfAF('nope'); // Promise that resolves to -1

AsyncAF(string).lastIndexOfAF('test', -5); // Promise that resolves to 0

AsyncAF(string).lastIndexOfAF('to', -7); // Promise that resolves to -1

// lastIndexOfAF on an array-like object
(async function () {
  const lastIndexOf2 = await AsyncAF(arguments).lastIndexOfAF(2);
  console.log(`the last index of 2 in the arguments array-like object is ${lastIndexOf2}`)
})(1, 1, 2, 2, 3, 3); // the last index of 2 in the arguments array-like object is 3</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>searchItem</code><td class=type><span class=param-type>any</span><td class=attributes><td class="last description"><p>the element or string to search for<tr><td class=name><code>fromIndex</code><td class=type><span class=param-type>Number</span><td class=attributes>&lt;optional><br><td class="last description"><p>the index at which to begin searching backwards for <code>searchItem</code>; a negative value searches from the index of <code>array/string.length - fromIndex</code>; defaults to <code>array/string.length - 1</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to the last index of <code>searchItem</code> if found; otherwise, <code>-1</code></div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Number></span></dl><h4 class=name id=mapAF><span class=type-signature></span>mapAF<span class=signature>(callback, thisArg<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Array>}</span></h4><div class=description><p>creates a new <code>Array</code> with the results of calling a provided function on every element in the original array<p>if any elements are a <code>Promise</code>, they will first be resolved in parallel and then processed</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.0.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>map</ul></dl><h5>Example</h5><pre class=prettyprint><code>const promises = [1, 2].map(n => Promise.resolve(n));


// basic usage
const doubled = AsyncAF(promises).mapAF(el => el * 2);

console.log(doubled); // Promise that resolves to [2, 4]

AsyncAF.logAF(doubled); // logs [2, 4]


// using .then
AsyncAF(promises).mapAF(el => el * 3).then(tripled => {
  console.log(tripled); // logs [3, 6]
});


// inside an async function
(async () => {
  const quadrupled = await AsyncAF(promises).mapAF(
    el => el * 4
  );
  console.log(quadrupled); // logs [4, 8]
})();</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>callback</code><td class=type><span class=param-type>Function</span><td class=attributes><td class="last description"><p>function that produces an element of the new <code>Array</code><p><code>callback</code> accepts three arguments:<ul><li><code>currentValue</code> value of the current element being processed in the array<li><code>index</code><em><code>(optional)</code></em> index of <code>currentValue</code> in the array<li><code>array</code><em><code>(optional)</code></em> the array that mapAF is being applied to</ul><tr><td class=name><code>thisArg</code><td class=type><span class=param-type>Object</span><td class=attributes>&lt;optional><br><td class="last description"><p>value to use as <code>this</code> when executing <code>callback</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to a new <code>Array</code> with each element being the result of calling <code>callback</code> on each original element</div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Array></span></dl><h4 class=name id=reduceAF><span class=type-signature></span>reduceAF<span class=signature>(callback, initialValue<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;any>}</span></h4><div class=description><p>applies a function against an accumulator and each element in an array (from left to right) to reduce it to a single value<p>if any elements are a <code>Promise</code>, they will first be resolved in parallel and then processed</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.1.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>reduce</ul></dl><h5>Example</h5><pre class=prettyprint><code>const promises = [1, 2, 3].map(n => Promise.resolve(n));


// basic usage
const sum = AsyncAF(promises).reduceAF((sum, num) => sum + num);

console.log(sum); // Promise that resolves to 6

AsyncAF.logAF(sum); // logs 6


// using .then
AsyncAF(promises).reduceAF((sum, num) => sum + num).then(sum => {
  console.log(sum); // logs 6
});


// inside an async function
(async () => {
  const sum = await AsyncAF(promises).reduceAF((sum, num) => sum + num);
  console.log(sum); // logs 6
})();


// using an initial value
AsyncAF(promises).reduceAF((sum, num) => sum + num, 12) // Promise that resolves to 18</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th>Default<th class=last>Description<tbody><tr><td class=name><code>callback</code><td class=type><span class=param-type>Function</span><td class=attributes><td class=default><td class="last description"><p>function to execute for each element<p><code>callback</code> accepts up to four arguments:<ul><li><code>accumulator</code> accumulates the callback's return values; the accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied<li><code>currentValue</code> value of the current element being processed in the array<li><code>index</code><em><code>(optional)</code></em> index of <code>currentValue</code> in the array<li><code>array</code><em><code>(optional)</code></em> the array that <code>reduceAF</code> is being applied to</ul><tr><td class=name><code>initialValue</code><td class=type><span class=param-type>any</span><td class=attributes>&lt;optional><br><td class=default><code>null</code><td class="last description"><p>value to use as the first argument to the first call of the callback; if no initial value is supplied, the first element in the array will be used; note: calling reduceAF on an empty array with no initial value will throw an error</table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to the reduced value</div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;any></span></dl><h4 class=name id=someAF><span class=type-signature></span>someAF<span class=signature>(callback, thisArg<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Boolean>}</span></h4><div class=description><p>tests whether at least one element in the array passes the test implemented by the provided callback function<p>if any elements are a <code>Promise</code>, they will first be resolved in parallel and then tested</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.3.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>some</ul></dl><h5>Example</h5><pre class=prettyprint><code>const promises = [1, 2, 3].map(n => Promise.resolve(n));


// basic usage
const someAreEven = AsyncAF(promises).someAF(n => n % 2 === 0);

console.log(someAreEven); // Promise that resolves to true

AsyncAF.logAF(someAreEven); // logs true


// using .then
AsyncAF(promises).someAF(n => n % 2 === 0).then(someAreEven => {
  console.log(someAreEven); // logs true
});


// inside an async function
(async () => {
  const someAreStrings = await AsyncAF(promises).someAF(
    n => typeof n === 'string'
  );
  console.log(someAreStrings); // logs false
})();</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>callback</code><td class=type><span class=param-type>Function</span><td class=attributes><td class="last description"><p>function that tests each element of the array<p><code>callback</code> accepts three arguments:<ul><li><code>currentValue</code> value of the current element being processed in the array<li><code>index</code><em><code>(optional)</code></em> index of <code>currentValue</code> in the array<li><code>array</code><em><code>(optional)</code></em> the array that <code>someAF</code> is being applied to</ul><tr><td class=name><code>thisArg</code><td class=type><span class=param-type>Object</span><td class=attributes>&lt;optional><br><td class="last description"><p>value to use as <code>this</code> when executing <code>callback</code></table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to <code>true</code> if the callback function returns a truthy value for any array element; otherwise, <code>false</code></div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Boolean></span></dl><h4 class=name id=logAF><span class=type-signature>(static) </span>logAF<span class=signature>(&hellip;items)</span><span class=type-signature> &rarr; {Promise.&lt;undefined>}</span></h4><div class=description><p>logs items to the console in the order given<p>if any items are a promise, they will first be resolved in parallel and then logged<pre class="prettyprint lang-js source"><code>import { logAF } from 'async-af';

const promise = new Promise(resolve => setTimeout(
 () => resolve(2), 1000)
);

logAF(1, promise, 3);

// @filename.js:6:12:
// 1 2 3
// in 0.998 secs</code></pre><p><strong>Note:</strong> since logAF returns a promise, the items in the previous example would be logged <em>after</em> any synchronous calls to <code>console.log</code><p>to produce in-order logging with any surrounding calls to <code>console.log</code>, <code>await</code> logAF:<pre class="prettyprint lang-js source"><code>logAF.options({ label: false, duration: false });

(async () => {
  console.log(1);
  // ...some code
  await logAF(promise);
  // ...some more code
  console.log(3);
})();

// 1
// 2
// 3</code></pre><p><strong>experimental feature</strong>: the label may not work correctly in all environments; to turn the label off, set <code>label</code> to <code>false</code> in <a href=AsyncAF.html#logAF_options>logAF.options</a>, where you can also change the label's format</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>3.0.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>log<li><a href=AsyncAF.html#logAF_options>logAF.options</a> to turn the label off or change its format<li>logAF.options.reset to reset options to default</ul></dl><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>items</code><td class=type><span class=param-type>any</span><td class=attributes>&lt;repeatable><br><td class="last description"><p>The items to print (log to the console)</table><h5>Returns:</h5><div class=param-desc><p>returns a <code>Promise</code> that logs items to the console</div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;undefined></span></dl><h4 class=name id=logAF_options><span class=type-signature>(static) </span>logAF.options<span class=signature>(options: {label<span class=signature-attributes>opt</span>, duration<span class=signature-attributes>opt</span>, labelFormat<span class=signature-attributes>opt</span>})</span><span class=type-signature> &rarr; {undefined}</span></h4><div class=description><p>Sets logging options for <a href=AsyncAF.html#logAF>logAF</a><p>accepts an options object with the following optional properties:<ul><li>label (<code>Boolean</code>) - set to <code>false</code> to disable logging the location of calls to logAF<li>duration (<code>Boolean</code>) - set to <code>false</code> to disable logging the time it takes (in secs) to complete each call to logAF<li>labelFormat (<code>String</code>|<code>Function</code>) - alters the format of logAF labels; choose between <code>file</code> (<em>default</em>), <code>path</code>, <code>parent</code>, <code>arrow</code>, or a custom string or function</ul><pre class="prettyprint lang-js source"><code>const promise = new Promise(resolve => setTimeout(
  () => resolve(1), 1000)
);</code></pre><p><strong>default logging</strong><pre class="prettyprint lang-js source"><code>logAF(promise, 2);

// @filename.js:24:1:
// 1 2
// in 0.998 secs</code></pre><p><strong>turn off label</strong><pre class="prettyprint lang-js source"><code>logAF.options({ label: false });
logAF(promise, 2);

// 1 2
// in 0.999 secs</code></pre><p><strong>turn off duration</strong><pre class="prettyprint lang-js source"><code>logAF.options({ duration: false });
logAF(promise, 2);

// @filename.js:24:1:
// 1 2</code></pre><p><strong>change labelFormat</strong><p>&#9679; file (<em>default</em>)<pre class="prettyprint lang-js source"><code>logAF.options({ labelFormat: 'file' });
logAF(promise, 2);

// @filename.js:24:1:
// 1 2
// in 0.998 secs</code></pre><p>&#9679; path<pre class="prettyprint lang-js source"><code>logAF.options({ labelFormat: 'path' });
logAF(promise, 2);

// @/Path/to/current/directory/filename.js:24:1:
// 1 2
// in 0.997 secs</code></pre><p>&#9679; parent<pre class="prettyprint lang-js source"><code>logAF.options({ labelFormat: 'parent' });
logAF(promise, 2);

// @parentDirectory/filename.js:24:1:
// 1 2
// in 0.998 secs</code></pre><p>&#9679; arrow<pre class="prettyprint lang-js source"><code>logAF.options({ labelFormat: 'arrow' });
logAF(promise, 2);

// ========================> 1 2
// in 0.999 secs</code></pre><p>&#9679; custom (create your own labelFormat)<ul><li>to set a custom labelFormat, set it to any string other than the formats above</ul><pre class="prettyprint lang-js source"><code>logAF.options({
 labelFormat: 'I logged this:'
});
logAF(promise, 2);

// I logged this: 1 2
// in 1.000 secs</code></pre><ul><li>labelFormat also accepts a function with access to an object containing the location variables <code>file</code>, <code>path</code>, <code>parent</code>, <code>arrow</code>, <code>line</code>, and <code>col</code></ul><p>e.g., to set the labelFormat to <code>file:line:col =&gt;</code>:<pre class="prettyprint lang-js source"><code>logAF.options({
 labelFormat: ({file, line, col}) => `${file}:${line}:${col} =>`
});
logAF(promise, 2);

// filename.js:24:1 => 1 2
// in 0.998 secs</code></pre><p>and just to demonstrate all the location variables in one custom format:<pre class="prettyprint lang-js source"><code>logAF.options({
  labelFormat: ({arrow, line, col, parent, file, path}) =>
`${arrow}
line: ${line}
col: ${col}
parent: ${parent}
file: ${file}
path: ${path}
`
});
logAF(promise, 2);

// ========================>
// line: 24
// col: 1
// parent: parentDirectory/
// file: filename.js
// path: /Full/path/to/the/parentDirectory/
// 1 2
// in 0.998 secs</code></pre><p>to reset <code>logAF.options</code> to its default values, call <code>logAF.options.reset</code><pre class="prettyprint lang-js source"><code>logAF.options.reset();

// options are now:
// label: true,
// duration: true,
// labelFormat: 'file'</code></pre></div><dl class=details><dt class=tag-see>See:<dd class=tag-see><ul><li><a href=AsyncAF.html#logAF>logAF</a><li>logAF.options.reset to reset options to default</ul></dl><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th class=last>Description<tbody><tr><td class=name><code>options</code><td class=type><span class=param-type>Object</span><td class="last description"><p>the options for logAF<h6>Properties</h6><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th>Default<th class=last>Description<tbody><tr><td class=name><code>label</code><td class=type><span class=param-type>Boolean</span><td class=attributes>&lt;optional><br><td class=default><code>true</code><td class="last description"><p>set to false to turn off the label<tr><td class=name><code>duration</code><td class=type><span class=param-type>Boolean</span><td class=attributes>&lt;optional><br><td class=default><code>true</code><td class="last description"><p>set to false to turn off duration<tr><td class=name><code>labelFormat</code><td class=type><span class=param-type>String</span> | <span class=param-type>Function</span><td class=attributes>&lt;optional><br><td class=default><code>file</code><td class="last description"><p>see examples for sample label formats</table></table><h5>Returns:</h5><div class=param-desc><p>sets the options for logAF</div><dl class=param-type><dt>Type<dd><span class=param-type>undefined</span></dl><h4 class=name id=splitAF><span class=type-signature></span>splitAF<span class=signature>(separator<span class=signature-attributes>opt</span>, limit<span class=signature-attributes>opt</span>)</span><span class=type-signature> &rarr; {Promise.&lt;Array.&lt;String>>}</span></h4><div class=description><p>splits a string into an array of substrings, using a specified separator to determine where to make each split</div><dl class=details><dt class=tag-since>Since:<dd class=tag-since><ul class=dummy><li>5.1.0</ul><dt class=tag-see>See:<dd class=tag-see><ul><li>split</ul></dl><h5>Example</h5><pre class=prettyprint><code>// basic usage
const str = Promise.resolve('s; p; l; i; t');

AsyncAF(str).splitAF('; '); // Promise that resolves to ['s', 'p', 'l', 'i', 't']

// no separator specified or separator not found
const str = Promise.resolve('splat');

AsyncAF(str).splitAF(); // Promise that resolves to ['splat']
AsyncAF(str).splitAF('n/a'); // Promise that resolves to ['splat']

// split to individual characters
const str = Promise.resolve('splitAF');

AsyncAF(str).splitAF(''); // Promise that resolves to ['s', 'p', 'l', 'i', 't', 'A', 'F']

// split on a regular expression
const str = Promise.resolve('splittedAF');

AsyncAF(str).splitAF(/sp|ted/); // Promise that resolves to ['', 'lit', 'AF']

// and w/ capturing parentheses

AsyncAF(str).splitAF(/(lit|AF)/); // Promise that resolves to ['sp', 'lit', '', 'AF', '']

// setting limit
const str = Promise.resolve('splitted');

AsyncAF(str).splitAF('', 5); // Promise that resolves to ['s', 'p', 'l', 'i', 't']
AsyncAF(str).splitAF('', 12); // Promise that resolves to ['s', 'p', 'l', 'i', 't', 't', 'e', 'd']
AsyncAF(str).splitAF('', 0); // Promise that resolves to []</code></pre><h5>Parameters:</h5><table class=params><thead><tr><th>Name<th>Type<th>Attributes<th class=last>Description<tbody><tr><td class=name><code>separator</code><td class=type><span class=param-type>String</span><td class=attributes>&lt;optional><br><td class="last description"><p>a regular expression or string that denotes the points at which each split should occur<ul><li>if a plain-text separator contains more than one character, the entire separator must be found to represent a split point<li>if separator is omitted or does not occur in the string, the array returned will contain one element consisting of the entire string<li>if separator is an empty string, the string is converted to an array of individual characters<li>if separator is a regular expression, the array returned will also contain any separators found as a result of matches within capturing parentheses</ul><tr><td class=name><code>limit</code><td class=type><span class=param-type>Number</span><td class=attributes>&lt;optional><br><td class="last description"><p>integer specifying a limit on the number of elements to be included in the result; when provided, the string is split at each occurrence of the specified separator but stops including elements when the limit is reached (or the end of the string, if reached sooner); any left-over text is not included in the result</table><h5>Returns:</h5><div class=param-desc><p><code>Promise</code> that resolves to an array of strings, split at each point the separator occurs in the given string</div><dl class=param-type><dt>Type<dd><span class=param-type>Promise.&lt;Array.&lt;String>></span></dl></article></section></div><br class=clear><footer>Documentation generated by <a href=https://github.com/jsdoc3/jsdoc>JSDoc 3.5.5</a> on Sunday, May 20, 2018 using the <a href=https://github.com/AsyncAF/docdash>AsyncAF/docdash</a> theme.</footer><script>prettyPrint()</script><script src=scripts/linenumber.js></script>
